{"version":3,"sources":["webpack:///./src/assets/convolution-images/boxblur.png","webpack:///./src/assets/fuego.jpg","webpack:///./src/assets/convolution-images/shader-edge.png","webpack:///./src/pages/convolutionMask.js","webpack:///./src/components/Code/convolution/convolutionCode.js","webpack:///./src/components/Code/convolution/convolutionCode2.js","webpack:///./src/components/Code/convolution/fragshadersharpen.js","webpack:///./src/components/Code/convolution/fragshaderedge.js","webpack:///./src/algorithms/convolution/kernels.js","webpack:///./src/assets/convolution-images/edgedetection.png","webpack:///./src/algorithms/convolution/convolution.js","webpack:///./src/assets/convolution-images/sharpen.png","webpack:///./src/assets/convolution-images/shader-sharpen.png","webpack:///./src/components/Code/Code.js"],"names":["module","exports","img","props","window","Sketch","loadable","className","style","fontSize","width","setup","p5","canvasParentRef","createCanvas","parent","resizeCanvas","clientWidth","noLoop","draw","background","loadPixels","image","height","convolution","EdgeDetectionKernel","BoxBlurKernel","SharpenKernel","preload","loadImage","fuego","Code","code","src","blurimage","alt","edgeimage","sharpenimage","edgeshader","sharpenshader","href","kernelProduct","x","y","kernel","red_channel","green_channel","blue_channel","i","j","loc","pixels","parseInt","copyImg","createImage","convol_rgb","alpha","updatePixels"],"mappings":"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","file":"component---src-pages-convolution-mask-js-fe5d99166750265a9556.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/boxblur-0b3f8e36ceaf1f8d451bfe460159dbab.png\";","module.exports = __webpack_public_path__ + \"static/fuego-15df1985b6d383a48079c4d3db3154d0.jpg\";","module.exports = __webpack_public_path__ + \"static/shader-edge-366855548d30306cfe95112fc3e68bcb.png\";","import \"bootstrap/dist/css/bootstrap.min.css\"\nimport React from \"react\"\nimport loadable from \"@loadable/component\"\n\nimport convolution from '../algorithms/convolution/convolution';\nimport {BoxBlurKernel, GaussianBlurKernel, SharpenKernel, EdgeDetectionKernel} from '../algorithms/convolution/kernels'\n\nimport Code from '../components/Code/Code';\nimport convCode from '../components/Code/convolution/convolutionCode';\nimport convCode2 from '../components/Code/convolution/convolutionCode2';\nimport fragshaderedge from '../components/Code/convolution/fragshaderedge';\nimport fragshadersharp from '../components/Code/convolution/fragshadersharpen';\nimport fuego from \"../assets/fuego.jpg\";\nimport blurimage from '../assets/convolution-images/boxblur.png';\nimport edgeimage from '../assets/convolution-images/edgedetection.png';\nimport sharpenimage from '../assets/convolution-images/sharpen.png';\nimport edgeshader from '../assets/convolution-images/shader-edge.png';\nimport sharpenshader from '../assets/convolution-images/shader-sharpen.png';\n\nlet img, canvas;\nexport default (props) => {\n  const preload = (p5) => {\n    img = p5.loadImage(fuego);\n  }\n\n  const setup = (p5, canvasParentRef) => {       \n    canvas = p5.createCanvas(800, 500)\n    canvas.parent(canvasParentRef)    \n    p5.resizeCanvas(canvasParentRef.clientWidth, 500*2/*canvasParentRef.clientWidth*0.625*/, false);\n    p5.noLoop();\n  }\n\n  const draw = (p5) => {\n    p5.background(0)\n    img.loadPixels();\n    p5.image(img,0,0, p5.width/2, p5.height/2)\n    p5.image(convolution(p5, img, EdgeDetectionKernel),p5.width/2,0, p5.width/2, p5.height/2);\n    p5.image(convolution(p5, img, BoxBlurKernel),0,p5.height/2, p5.width/2, p5.height/2);\n    p5.image(convolution(p5, img, SharpenKernel),p5.width/2,p5.height/2, p5.width/2, p5.height/2);  \n  }\n\n  if (typeof window !== \"undefined\") {\n    const Sketch = loadable(() => import(\"react-p5\"))\n    return (\n      <div className=\"ml-5 mr-5 my-3\">\n        <h1>MASCARAS DE CONVOLUCIÓN</h1>\n        <hr className=\"my-3\"></hr>\n        <p className=\"mb-4 text-justify\" style={{fontSize:'20px', width:'60%'}}>En esta sección implementamos las mascaras de convolución para una imagen aplicando 3 tipos de kernels \n          <strong>la imagen #1 (esquina superior izquierda)</strong> es la imagen original, la <strong>imagen #2 (esquina superior derecha)</strong> es la imagen con el kernel de detección de bordes,\n          <strong>la imagen #3 (esquina inferior izquierda)</strong> es la imagen con un kernel BoxBlur, y la <strong>imagen #4 (esquina inferior derecha)</strong> es la imagen con el kernel Sharpen.\n        </p>\n        <Sketch setup={setup} draw={draw} preload={preload}/>\n        <br></br>\n        <h2>CODIGO</h2>\n        <Code code={convCode}></Code>\n        <Code code={convCode2}></Code>\n        <br></br>\n        <h2>KERNEL BOX BLUR</h2>\n        <p className=\"text-justify\" style={{fontSize:'20px', width:'60%'}}>\n          Un Box Blur es un filtro lineal en el que cada pixel resulta del promedio de sus vecinos tomando un kernel de 3x3          \n        </p>\n        <img src={blurimage} alt=\"boxblur\"/>\n        <br></br>\n        <h2>KERNEL EDGE DETECTION</h2>\n        <p className=\"text-justify\" style={{fontSize:'20px', width:'60%'}}>\n          Edge Detection es una técnica de procesamiento de imágenes para encontrar los puntos de cambio drastico del brillo en una imagen\n        </p>\n        <img src={edgeimage} alt=\"edgeimage\"/>\n        <br></br>\n        <h2>KERNEL SHARPEN</h2>\n        <p className=\"text-justify\" style={{fontSize:'20px', width:'60%'}}>\n          Sharpen es un efecto que se aplica a las imágenes para darles una apariencia más nítida.\n        </p>\n        <img src={sharpenimage} alt=\"sharpen\"/>\n        <br></br>\n        <h1>CONVOLUCIÓN POR HARDWARE con SHADERS</h1>\n        <p className=\"text-justify\" style={{fontSize:'20px', width:'60%'}}>\n          Debido a dificultades en la implementación de shaders con p5 decidimos utilizar Processing para estos aplicandolo a 2 tipos de kernels: Edge Detection y Sharpen\n        </p>\n        <img src={edgeshader} alt=\"edge\"/><img src={sharpenshader} alt=\"sharpen\"/>\n        <br></br>\n        <Code code={fragshadersharp}></Code>\n        <Code code={fragshaderedge}></Code>\n        <br></br>\n        <h2>CONCLUSIONES</h2>\n        <ul className=\"mb-5\">\n          <li>1) Aunque apliquemos kernels habran algunas imagenes cuya imagen resultante sea dificil diferenciar de la original a simple vista</li>\n          <li>2) Con Variar solo uno de los numeros del kernel se pueden obtener resultados muy distintos</li>\n          <li>3) Si aplicamos cualquiera de los filtros desde processing o p5 usando Shaders la velocidad con que renderizo la imagen o inclusive un video es muy superior</li>\n        </ul>\n        <br></br>\n        <h2>REFERENCIAS</h2>\n        <a href=\"https://en.wikipedia.org/wiki/Kernel_(image_processing)\">https://en.wikipedia.org/wiki/Kernel_(image_processing)</a><br></br>\n        <a href=\"https://www.slrlounge.com/glossary/image-sharpening-definition/\">https://www.slrlounge.com/glossary/image-sharpening-definition/</a>\n        <br></br><br></br><br></br>\n      </div>\n    )\n  } else\n    return null\n}\n","const code = `---Archivo React.js\nconst preload = (p5) => {\n  img = p5.loadImage(fuego);\n}\n\nconst setup = (p5, canvasParentRef) => {       \n  canvas = p5.createCanvas(800, 500)\n  canvas.parent(canvasParentRef)    \n  p5.resizeCanvas(canvasParentRef.clientWidth, 500*2, false);\n  p5.noLoop();\n}\n\nconst draw = (p5) => {\n  p5.background(0)\n  img.loadPixels();\n  p5.image(img,0,0, p5.width/2, p5.height/2)\n  p5.image(convolution(p5, img, EdgeDetectionKernel),p5.width/2,0, p5.width/2, p5.height/2);\n  p5.image(convolution(p5, img, BoxBlurKernel),0,p5.height/2, p5.width/2, p5.height/2);\n  p5.image(convolution(p5, img, SharpenKernel),p5.width/2,p5.height/2, p5.width/2, p5.height/2);  \n}\nreturn (\n  <Sketch setup={setup} draw={draw} preload={preload}/>\n)\n`\nexport default code","const code = `---Algoritmo Convolución en P5.js\nconst blur = 1.0 / 9.0;\nconst blur_gaussian = 1.0/16.0;\n\nconst BoxBlurKernel = [[ blur, blur, blur ], [ blur, blur, blur ], [ blur, blur, blur ]];   \nconst GaussianBlurKernel = [[1*blur_gaussian,2*blur_gaussian,1*blur_gaussian],[2*blur_gaussian,4*blur_gaussian,2*blur_gaussian],[1*blur_gaussian,2*blur_gaussian,1*blur_gaussian]];\nconst SharpenKernel = [[0, -1, 0],[-1, 5, -1],[0,-1,0]];\nconst EdgeDetectionKernel = [[-1, -1 , -1],[-1, 8, -1],[-1, -1, -1]];\n\nconst convolution = (p5, img, kernel) => {\n    let copyImg = p5.createImage(img.width, img.height);\n    copyImg.loadPixels();\n\n    for(var x = 1; x < img.width - 1; ++x){\n        for(var y = 1; y < img.height - 1; ++y){\n            let loc = (x + y*img.width) * 4;\n            let convol_rgb = kernelProduct(img, x, y, kernel);\n\n            copyImg.pixels[loc] = convol_rgb[0];\n            copyImg.pixels[loc+1] = convol_rgb[1];\n            copyImg.pixels[loc+2] = convol_rgb[2];\n            copyImg.pixels[loc+3] = p5.alpha(1);            \n        }        \n    }\n      \n    copyImg.updatePixels();\n    return copyImg;    \n}\n\nfunction kernelProduct(img, x, y, kernel){\n    var red_channel = 0.0;\n    var green_channel = 0.0;\n    var blue_channel = 0.0;\n    for(var i = -1; i <= 1; ++i){\n      for(var j = -1; j <= 1; ++j){\n        let loc = ((x+i) + (y+j)*img.width)*4;\n\n         red_channel += kernel[i+1][j+1] * img.pixels[loc];\n         green_channel += kernel[i+1][j+1] * img.pixels[loc + 1];\n         blue_channel += kernel[i+1][j+1] * img.pixels[loc + 2];\n      }\n    }\n    return [parseInt(red_channel), parseInt(green_channel), parseInt(blue_channel)];\n  }\n\n  export default convolution;\n`\nexport default code;","const code = `---Archivo frag.glsl\nuniform sampler2D texture;\nuniform vec2 texOffset;\n\nvarying vec4 vertColor;\nvarying vec4 vertTexCoord;\n\nvoid main() {\n  vec2 tc0 = vertTexCoord.st + vec2(-texOffset.s, -texOffset.t);\n  vec2 tc1 = vertTexCoord.st + vec2(         0.0, -texOffset.t);\n  vec2 tc2 = vertTexCoord.st + vec2(+texOffset.s, -texOffset.t);\n  vec2 tc3 = vertTexCoord.st + vec2(-texOffset.s,          0.0);\n  vec2 tc4 = vertTexCoord.st + vec2(         0.0,          0.0);\n  vec2 tc5 = vertTexCoord.st + vec2(+texOffset.s,          0.0);\n  vec2 tc6 = vertTexCoord.st + vec2(-texOffset.s, +texOffset.t);\n  vec2 tc7 = vertTexCoord.st + vec2(         0.0, +texOffset.t);\n  vec2 tc8 = vertTexCoord.st + vec2(+texOffset.s, +texOffset.t);\n  \n  vec4 col0 = texture2D(texture, tc0);\n  vec4 col1 = texture2D(texture, tc1);\n  vec4 col2 = texture2D(texture, tc2);\n  vec4 col3 = texture2D(texture, tc3);\n  vec4 col4 = texture2D(texture, tc4);\n  vec4 col5 = texture2D(texture, tc5);\n  vec4 col6 = texture2D(texture, tc6);\n  vec4 col7 = texture2D(texture, tc7);\n  vec4 col8 = texture2D(texture, tc8);\n\n  vec4 sum = - (col1 + col3 + col5 + col7) + 5 * col4;\n  \n  gl_FragColor = vec4(sum.rgb, 1.0) * vertColor;\n}\n`\nexport default code","const code = `---Archivo frag.glsl\nuniform sampler2D texture;\nuniform vec2 texOffset;\n\nvarying vec4 vertColor;\nvarying vec4 vertTexCoord;\n\nvoid main() {\n  vec2 tc0 = vertTexCoord.st + vec2(-texOffset.s, -texOffset.t);\n  vec2 tc1 = vertTexCoord.st + vec2(         0.0, -texOffset.t);\n  vec2 tc2 = vertTexCoord.st + vec2(+texOffset.s, -texOffset.t);\n  vec2 tc3 = vertTexCoord.st + vec2(-texOffset.s,          0.0);\n  vec2 tc4 = vertTexCoord.st + vec2(         0.0,          0.0);\n  vec2 tc5 = vertTexCoord.st + vec2(+texOffset.s,          0.0);\n  vec2 tc6 = vertTexCoord.st + vec2(-texOffset.s, +texOffset.t);\n  vec2 tc7 = vertTexCoord.st + vec2(         0.0, +texOffset.t);\n  vec2 tc8 = vertTexCoord.st + vec2(+texOffset.s, +texOffset.t);\n  \n  vec4 col0 = texture2D(texture, tc0);\n  vec4 col1 = texture2D(texture, tc1);\n  vec4 col2 = texture2D(texture, tc2);\n  vec4 col3 = texture2D(texture, tc3);\n  vec4 col4 = texture2D(texture, tc4);\n  vec4 col5 = texture2D(texture, tc5);\n  vec4 col6 = texture2D(texture, tc6);\n  vec4 col7 = texture2D(texture, tc7);\n  vec4 col8 = texture2D(texture, tc8);\n\n  vec4 sum = 8.0 * col4 - (col0 + col1 + col2 + col3 + col5 + col6 + col7 + col8); \n  gl_FragColor = vec4(sum.rgb, 1.0) * vertColor; \n}\n`\nexport default code","const blur = 1.0 / 9.0;\nconst blur_gaussian = 1.0/16.0;\n\nexport const BoxBlurKernel = [[ blur, blur, blur ], [ blur, blur, blur ], [ blur, blur, blur ]];   \nexport const GaussianBlurKernel = [[1*blur_gaussian,2*blur_gaussian,1*blur_gaussian],[2*blur_gaussian,4*blur_gaussian,2*blur_gaussian],[1*blur_gaussian,2*blur_gaussian,1*blur_gaussian]];\nexport const SharpenKernel = [[0, -1, 0],[-1, 5, -1],[0,-1,0]];\nexport const EdgeDetectionKernel = [[-1, -1 , -1],[-1, 8, -1],[-1, -1, -1]];","module.exports = __webpack_public_path__ + \"static/edgedetection-65d0d7fc922dd65f11a0858295205535.png\";","const convolution = (p5, img, kernel) => {\n    let copyImg = p5.createImage(img.width, img.height);\n    copyImg.loadPixels();\n\n    for(var x = 1; x < img.width - 1; ++x){\n        for(var y = 1; y < img.height - 1; ++y){\n            let loc = (x + y*img.width) * 4;\n            let convol_rgb = kernelProduct(img, x, y, kernel);\n\n            copyImg.pixels[loc] = convol_rgb[0];\n            copyImg.pixels[loc+1] = convol_rgb[1];\n            copyImg.pixels[loc+2] = convol_rgb[2];\n            copyImg.pixels[loc+3] = p5.alpha(1);            \n        }        \n    }\n      \n    copyImg.updatePixels();\n    return copyImg;    \n}\n\nfunction kernelProduct(img, x, y, kernel){\n    var red_channel = 0.0;\n    var green_channel = 0.0;\n    var blue_channel = 0.0;\n    for(var i = -1; i <= 1; ++i){\n      for(var j = -1; j <= 1; ++j){\n        let loc = ((x+i) + (y+j)*img.width)*4;\n\n         red_channel += kernel[i+1][j+1] * img.pixels[loc];\n         green_channel += kernel[i+1][j+1] * img.pixels[loc + 1];\n         blue_channel += kernel[i+1][j+1] * img.pixels[loc + 2];\n      }\n    }\n    return [parseInt(red_channel), parseInt(green_channel), parseInt(blue_channel)];\n  }\n\n  export default convolution;","module.exports = __webpack_public_path__ + \"static/sharpen-13f80781cff70f254e0fe22d0b53c581.png\";","module.exports = __webpack_public_path__ + \"static/shader-sharpen-a8793aad420292ce512a49a542a572ae.png\";","import \"bootstrap/dist/css/bootstrap.min.css\"\nimport React from \"react\"\nimport loadable from \"@loadable/component\"\n\nexport default (props) => {\n    return (\n        <pre className=\"bg-light\">\n            {props.code}\n        </pre>\n    )\n}"],"sourceRoot":""}