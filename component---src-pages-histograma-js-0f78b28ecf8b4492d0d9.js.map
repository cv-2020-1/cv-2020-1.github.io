{"version":3,"sources":["webpack:///./src/assets/mujer.png","webpack:///./src/pages/histograma.js"],"names":["module","exports","img","segmentedImage","hist","Array","fill","probability","minVar","Number","MAX_VALUE","minThreshold","window","Sketch","loadable","className","setup","p5","canvasParentRef","createCanvas","width","height","parent","colorMode","HSB","image","loadPixels","x","y","bright","int","brightness","get","map","imageTotalPixels","pixels","length","i","t","c1Weight","c2Weight","c1Mean","c2Mean","c1Var","c2Var","weightedVar","set","color","updatePixels","push","stroke","translate","k","which","max","line","pop","preload","loadImage","imagen","href"],"mappings":"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","file":"component---src-pages-histograma-js-0f78b28ecf8b4492d0d9.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/mujer-b9d874a2aec8953de70bd3dcd0b58d89.png\";","import React from \"react\";\r\nimport loadable from \"@loadable/component\";\r\nimport imagen from \"../assets/mujer.png\";\r\n\r\nexport default () => {\r\n\tvar img;\r\n\tvar segmentedImage;\r\n    var hist = new Array(256).fill(0);\r\n    var probability = new Array(256).fill(0);\r\n\tvar minVar = Number.MAX_VALUE;\r\n\tvar minThreshold = 0;\r\n\r\n\tfunction preload(p5) {\r\n\t\timg = p5.loadImage(imagen);\r\n\t\tsegmentedImage = p5.loadImage(imagen);\r\n\t}\r\n\r\n\tfunction setup(p5, canvasParentRef) {\r\n\t\tp5.createCanvas((img.width * 3) + 20, img.height + 10).parent(canvasParentRef);\r\n\t\tp5.colorMode(p5.HSB, 255);\r\n\t\tp5.image(img, 0, 0);\r\n\r\n\t\timg.loadPixels();\r\n\r\n\t\t//Calcula el histograma\r\n\t\tfor (let x = 0; x < img.width; x++) {\r\n\t\t\tfor (let y = 0; y < img.height; y++) {\r\n\t\t\t\tvar bright = p5.int(p5.brightness(p5.get(x, y)));\r\n\t\t\t\thist[bright]++;\r\n\t\t\t}\r\n\t\t}\r\n\t\thist = hist.map((x) => (x === 0 ? 1 : x));\r\n\t\t\r\n\t\t/////////////////////ALGORITMO OTSU//////////////////////////\r\n\r\n        //Calculo de la probabilidad para cada valor de intensidad\r\n        var imageTotalPixels = img.pixels.length / 4;\r\n        for (var i = 0; i < 256; i++) {\r\n            probability[i] = (hist[i]) / imageTotalPixels;\r\n        }\r\n\r\n        //iterar sobre todos los posibles Thresholds y encontrar la varianza minima\r\n        for(var t = 0; t < 255; t++) {\r\n            //pesos clase 1 y 2\r\n            var c1Weight = 0;\r\n            var c2Weight = 0;\r\n            for(var i = 0; i < t; i++) {\r\n                c1Weight += probability[i];\r\n            }\r\n            for(var i = t + 1; i < 256; i++) {\r\n                c2Weight += probability[i];\r\n            }\r\n\r\n            //promedios calse 1 y 2\r\n            var c1Mean = 0;\r\n            var c2Mean = 0;\r\n            for(var i = 0; i < t; i++) {\r\n                c1Mean += (i * probability[i]) / c1Weight;\r\n            }\r\n            for(var i = t + 1; i < 256; i++) {\r\n                c2Mean += (i * probability[i]) / c2Weight;\r\n            }\r\n\r\n            //varianzas clase 1 y 2\r\n            var c1Var = 0; \r\n            var c2Var = 0;\r\n            for(var i = 0; i < t; i++) {\r\n                c1Var += ((i - c1Mean)**2) * (probability[1] / c1Weight);\r\n            }\r\n            for(var i = t + 1; i < 256; i++) {\r\n                c2Var += ((i - c2Mean)**2) * (probability[1] / c2Weight);\r\n\t\t\t}\r\n\t\t\t\r\n            var weightedVar = (c1Weight * c1Var) + (c2Weight * c2Var);\r\n            if(weightedVar < minVar) {\r\n                minVar = weightedVar;\r\n                minThreshold = t;\r\n            }\r\n        }\r\n\t\t///////////////FIN OTSU//////////////////////////\r\n\r\n\r\n\t\t//Segmenta la imagen\r\n\t\tsegmentedImage.loadPixels();\r\n\t\tfor (let x = 0; x < segmentedImage.width; x++) {\r\n\t\t\tfor (let y = 0; y < segmentedImage.height; y++) {\r\n                var bright = p5.int(p5.brightness(p5.get(x, y)));\r\n\t\t\t\tif (bright <= minThreshold) {\r\n                    segmentedImage.set(x, y, p5.color(0));\r\n                } \r\n                else if (bright > minThreshold) {\r\n                    segmentedImage.set(x, y, p5.color(255));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsegmentedImage.updatePixels();\r\n\t\tp5.image(segmentedImage, img.width + 5, 0);\r\n\r\n        // #############################\r\n\t\tp5.push();\r\n\t\tp5.stroke('red');\r\n        p5.translate((img.width * 2) + 10, 0);\r\n        \r\n\t\tfor (var k = 0; k < img.width; k += 2) {\r\n\t\t\tvar which = p5.int(p5.map(k, 0, img.width, 0, 255));\r\n\t\t\tvar y = p5.map(hist[which], 0, p5.max(hist), img.height, 0);\r\n\t\t\tp5.line(k, img.height, k, y);\r\n\t\t}\r\n\t\tp5.pop();\r\n\t}\r\n\r\n\tif (typeof window !== \"undefined\") {\r\n\t\tconst Sketch = loadable(() => import(\"react-p5\"));\r\n\t\treturn (\r\n\t\t\t<div className=\"ml-5 mr-5 my-3\">\r\n\t\t\t\t<h1>Histograma y segmentación imagen en escala de grises y color</h1>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tPara el proceso de segmentación se uso Thresholding usando el metodo\r\n\t\t\t\t\tde Otsu para el calculo automatico del valor umbral y el modelo de\r\n\t\t\t\t\tcolor HSV sobre la imagen para extraer el valor de intensidad del\r\n\t\t\t\t\tpixel, que es un valor entero entre 0 y (L - 1) siendo L el numero\r\n\t\t\t\t\tmaximo que un pixel puede representar. Para este caso particular como\r\n\t\t\t\t\tla imagen esta a escala de grises, L toma un valor de 256; siendo 0\r\n\t\t\t\t\tnegro puro y 255 blanco puro. Se hizo el analisis con una imagen a color \r\n\t\t\t\t\tcomo resultado se tuvo una imagen segmentada menos precisa. Se presume\r\n\t\t\t\t\tque esto es porque la diferencia de los dos picos mas grandes del histograma\r\n\t\t\t\t\tde la imagen a color no es significativa y por lo tanto el metodo Otsu que funciona mejor\r\n\t\t\t\t\tcon histogramas bimodales no se desempeña optimamente, si se desea observar el resultado \r\n\t\t\t\t\tcon imagen a color se puede cambiar en la parte de import imagen el nombre mujer por reg.\r\n\t\t\t\t</p>\r\n\t\t\t\t<Sketch className=\"d-flex justify-content-center\"  setup={setup} preload={preload} />\r\n\t\t\t\t<h2>Referencias</h2>\r\n\t\t\t\t<ul>\r\n\t\t\t\t\t<li><a href=\"https://en.wikipedia.org/wiki/Image_segmentation\">Segmentación</a></li>\r\n\t\t\t\t\t<li><a href=\"https://es.wikipedia.org/wiki/Modelo_de_color_HSV\">Modelo de color HSV</a></li>\r\n\t\t\t\t\t<li><a href=\"https://es.wikipedia.org/wiki/M%C3%A9todo_del_valor_umbral\">Metodo valor umbral</a></li>\r\n\t\t\t\t\t<li><a href=\"https://en.wikipedia.org/wiki/Otsu%27s_method\">Metodo de Otsu</a></li>\r\n\t\t\t\t\t<li><a href=\"https://processing.org/examples/histogram.html\">https://processing.org/examples/histogram.html</a></li>\r\n\t\t\t\t\t<li><a href=\"https://editor.p5js.org/ebenjmuse/sketches/HyPfeGkCZ\">https://editor.p5js.org/ebenjmuse/sketches/HyPfeGkCZ</a></li>\r\n\t\t\t\t\t<li>Handbook of Image and Video Processing (Second Edition)</li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\tMetz, M. (2018). Optimum Global Thresholding Using Otsu´s Method.\r\n\t\t\t\t\t\thttps://github.com/Michael-Metz/image-processing/blob/master/otsus-method-paper.pdf\r\n\t\t\t\t\t</li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\tDigital Image Processing (CS/ECE 545) Lecture 2: Histograms and\r\n\t\t\t\t\t\tPoint Operations (Part 1)\r\n\t\t\t\t\t</li>\r\n\t\t\t\t</ul>\r\n\t\t\t</div>\r\n\t\t);\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n};\r\n"],"sourceRoot":""}