{"version":3,"sources":["webpack:///./src/assets/mujer.png","webpack:///./src/pages/histograma.js","webpack:///./src/components/Code/otsu.js","webpack:///./src/assets/SegColor.png","webpack:///./src/components/Code/Code.js"],"names":["module","exports","img","segmentedImage","hist","Array","fill","probability","minVar","Number","MAX_VALUE","minThreshold","window","Sketch","loadable","className","setup","p5","canvasParentRef","createCanvas","width","height","parent","colorMode","HSB","image","loadPixels","x","y","bright","int","brightness","get","map","imageTotalPixels","pixels","length","i","t","c1Weight","c2Weight","c1Mean","c2Mean","c1Var","c2Var","weightedVar","set","color","updatePixels","push","stroke","translate","k","which","max","line","pop","preload","loadImage","imagen","src","SegColor","alt","Code","code","href","props"],"mappings":"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","file":"component---src-pages-histograma-js-12c846926391fa15a32f.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/mujer-b9d874a2aec8953de70bd3dcd0b58d89.png\";","import React from \"react\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport loadable from \"@loadable/component\";\nimport imagen from \"../assets/mujer.png\";\nimport SegColor from \"../assets/SegColor.png\"\n\nimport Code from '../components/Code/Code';\nimport otsu from '../components/Code/otsu';\n\nexport default () => {\n\tvar img;\n\tvar segmentedImage;\n    var hist = new Array(256).fill(0);\n    var probability = new Array(256).fill(0);\n\tvar minVar = Number.MAX_VALUE;\n\tvar minThreshold = 0;\n\n\tfunction preload(p5) {\n\t\timg = p5.loadImage(imagen);\n\t\tsegmentedImage = p5.loadImage(imagen);\n\t}\n\n\tfunction setup(p5, canvasParentRef) {\n\t\tp5.createCanvas((img.width * 3) + 20, img.height + 10).parent(canvasParentRef);\n\t\tp5.colorMode(p5.HSB, 255);\n\t\tp5.image(img, 0, 0);\n\n\t\timg.loadPixels();\n\n\t\t//Calcula el histograma\n\t\tfor (let x = 0; x < img.width; x++) {\n\t\t\tfor (let y = 0; y < img.height; y++) {\n\t\t\t\tvar bright = p5.int(p5.brightness(p5.get(x, y)));\n\t\t\t\thist[bright]++;\n\t\t\t}\n\t\t}\n\t\thist = hist.map((x) => (x === 0 ? 1 : x));\n\t\t\n\t\t/////////////////////ALGORITMO OTSU//////////////////////////\n\n        //Calculo de la probabilidad para cada valor de intensidad\n        var imageTotalPixels = img.pixels.length / 4;\n        for (var i = 0; i < 256; i++) {\n            probability[i] = (hist[i]) / imageTotalPixels;\n        }\n\n        //iterar sobre todos los posibles Thresholds y encontrar la varianza minima\n        for(var t = 0; t < 255; t++) {\n            //pesos clase 1 y 2\n            var c1Weight = 0;\n            var c2Weight = 0;\n            for(var i = 0; i < t; i++) {\n                c1Weight += probability[i];\n            }\n            for(var i = t + 1; i < 256; i++) {\n                c2Weight += probability[i];\n            }\n\n            //promedios calse 1 y 2\n            var c1Mean = 0;\n            var c2Mean = 0;\n            for(var i = 0; i < t; i++) {\n                c1Mean += (i * probability[i]) / c1Weight;\n            }\n            for(var i = t + 1; i < 256; i++) {\n                c2Mean += (i * probability[i]) / c2Weight;\n            }\n\n            //varianzas clase 1 y 2\n            var c1Var = 0; \n            var c2Var = 0;\n            for(var i = 0; i < t; i++) {\n                c1Var += ((i - c1Mean)**2) * (probability[1] / c1Weight);\n            }\n            for(var i = t + 1; i < 256; i++) {\n                c2Var += ((i - c2Mean)**2) * (probability[1] / c2Weight);\n\t\t\t}\n\t\t\t\n            var weightedVar = (c1Weight * c1Var) + (c2Weight * c2Var);\n            if(weightedVar < minVar) {\n                minVar = weightedVar;\n                minThreshold = t;\n            }\n        }\n\t\t///////////////FIN OTSU//////////////////////////\n\n\n\t\t//Segmenta la imagen\n\t\tsegmentedImage.loadPixels();\n\t\tfor (let x = 0; x < segmentedImage.width; x++) {\n\t\t\tfor (let y = 0; y < segmentedImage.height; y++) {\n                var bright = p5.int(p5.brightness(p5.get(x, y)));\n\t\t\t\tif (bright <= minThreshold) {\n                    segmentedImage.set(x, y, p5.color(0));\n                } \n                else if (bright > minThreshold) {\n                    segmentedImage.set(x, y, p5.color(255));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsegmentedImage.updatePixels();\n\t\tp5.image(segmentedImage, img.width + 5, 0);\n\n        // #############################\n\t\tp5.push();\n\t\tp5.stroke('red');\n        p5.translate((img.width * 2) + 10, 0);\n        \n\t\tfor (var k = 0; k < img.width; k += 2) {\n\t\t\tvar which = p5.int(p5.map(k, 0, img.width, 0, 255));\n\t\t\tvar y = p5.map(hist[which], 0, p5.max(hist), img.height, 0);\n\t\t\tp5.line(k, img.height, k, y);\n\t\t}\n\t\tp5.pop();\n\t}\n\n\tif (typeof window !== \"undefined\") {\n\t\tconst Sketch = loadable(() => import(\"react-p5\"));\n\t\treturn (\n\t\t\t<div className=\"ml-5 mr-5 my-3\">\n\t\t\t\t<h1>Histograma y segmentación imagen en escala de grises y color</h1>\n\t\t\t\t<hr className=\"my-3\"></hr>\n\t\t\t\t<p>\n\t\t\t\t\tPara el proceso de segmentación se uso Thresholding usando el metodo\n\t\t\t\t\tde Otsu para el calculo automatico del valor umbral y el modelo de\n\t\t\t\t\tcolor HSV sobre la imagen para extraer el valor de intensidad del\n\t\t\t\t\tpixel, que es un valor entero entre 0 y (L - 1) siendo L el numero\n\t\t\t\t\tmaximo que un pixel puede representar. Para este caso particular como\n\t\t\t\t\tla imagen esta a escala de grises, L toma un valor de 256; siendo 0\n\t\t\t\t\tnegro puro y 255 blanco puro.\n\t\t\t\t</p>\n\t\t\t\t<Sketch className=\"d-flex justify-content-center\"  setup={setup} preload={preload} />\n\t\t\t\t<div className=\"d-flex justify-content-center\">\n\t\t\t\t\t<img src={SegColor} alt=\"SegColor\"/>\n\t\t\t\t</div>\n\t\t\t\t<h2>Algoritmo metodo Thresholding Otsu</h2>\n\t\t\t\t<Code code={otsu}></Code>\n\t\t\t\t<h2>Conclusiones</h2>\n\t\t\t\t<ul>\n\t\t\t\t\t<li>En el analisis con una imagen a color se tuvo una imagen \n\t\t\t\t\t\tsegmentada menos precisa. Se presume que esto es porque la \n\t\t\t\t\t\tdiferencia de los dos picos mas grandes del histograma de la imagen que se uso\n\t\t\t\t\t\tcomo prueba no es significativa y por lo tanto el metodo Otsu que funciona mejor\n\t\t\t\t\t\tcon histogramas bimodales no se desempeño optimamente\n\t\t\t\t\t</li>\n\t\t\t\t\t<li>\n\t\t\t\t\t\tEl metodo de Otsu es un metodo sencillo que se implementa en tiempo lineal. Tiene la \n\t\t\t\t\t\tlimitación de desempeñarse optimamente unicamente en histogramas bimodales aunque existen tecnicas para\n\t\t\t\t\t\tsuplir esta falencia  \n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\t\t\t\t<h2>Referencias</h2>\n\t\t\t\t<ul>\n\t\t\t\t\t<li><a href=\"https://en.wikipedia.org/wiki/Image_segmentation\">Segmentación</a></li>\n\t\t\t\t\t<li><a href=\"https://es.wikipedia.org/wiki/Modelo_de_color_HSV\">Modelo de color HSV</a></li>\n\t\t\t\t\t<li><a href=\"https://es.wikipedia.org/wiki/M%C3%A9todo_del_valor_umbral\">Metodo valor umbral</a></li>\n\t\t\t\t\t<li><a href=\"https://en.wikipedia.org/wiki/Otsu%27s_method\">Metodo de Otsu</a></li>\n\t\t\t\t\t<li><a href=\"https://processing.org/examples/histogram.html\">https://processing.org/examples/histogram.html</a></li>\n\t\t\t\t\t<li><a href=\"https://editor.p5js.org/ebenjmuse/sketches/HyPfeGkCZ\">https://editor.p5js.org/ebenjmuse/sketches/HyPfeGkCZ</a></li>\n\t\t\t\t\t<li>Handbook of Image and Video Processing (Second Edition)</li>\n\t\t\t\t\t<li>\n\t\t\t\t\t\tMetz, M. (2018). Optimum Global Thresholding Using Otsu´s Method.\n\t\t\t\t\t\thttps://github.com/Michael-Metz/image-processing/blob/master/otsus-method-paper.pdf\n\t\t\t\t\t</li>\n\t\t\t\t\t<li>\n\t\t\t\t\t\tDigital Image Processing (CS/ECE 545) Lecture 2: Histograms and\n\t\t\t\t\t\tPoint Operations (Part 1)\n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t);\n\t} else {\n\t\treturn null;\n\t}\n};\n","const code = `---Archivo React.js\n//Calcula el histograma\nfor (let x = 0; x < img.width; x++) {\n    for (let y = 0; y < img.height; y++) {\n        var bright = p5.int(p5.brightness(p5.get(x, y)));\n        hist[bright]++;\n    }\n}\nhist = hist.map((x) => (x === 0 ? 1 : x));\n\n//Calculo de la probabilidad para cada valor de intensidad\nvar imageTotalPixels = img.pixels.length / 4;\nfor (var i = 0; i < 256; i++) {\n    probability[i] = (hist[i]) / imageTotalPixels;\n}\n\n//iterar sobre todos los posibles Thresholds y encontrar la varianza minima\nfor(var t = 0; t < 255; t++) {\n    //pesos clase 1 y 2\n    var c1Weight = 0;\n    var c2Weight = 0;\n    for(var i = 0; i < t; i++) {\n        c1Weight += probability[i];\n    }\n    for(var i = t + 1; i < 256; i++) {\n        c2Weight += probability[i];\n    }\n\n    //promedios calse 1 y 2\n    var c1Mean = 0;\n    var c2Mean = 0;\n    for(var i = 0; i < t; i++) {\n        c1Mean += (i * probability[i]) / c1Weight;\n    }\n    for(var i = t + 1; i < 256; i++) {\n        c2Mean += (i * probability[i]) / c2Weight;\n    }\n\n    //varianzas clase 1 y 2\n    var c1Var = 0; \n    var c2Var = 0;\n    for(var i = 0; i < t; i++) {\n        c1Var += ((i - c1Mean)**2) * (probability[1] / c1Weight);\n    }\n    for(var i = t + 1; i < 256; i++) {\n        c2Var += ((i - c2Mean)**2) * (probability[1] / c2Weight);\n    }\n    \n    var weightedVar = (c1Weight * c1Var) + (c2Weight * c2Var);\n    if(weightedVar < minVar) {\n        minVar = weightedVar;\n        minThreshold = t;\n    }\n}\n`\nexport default code","module.exports = __webpack_public_path__ + \"static/SegColor-828134a9418a02165cef1bead096625a.png\";","import \"bootstrap/dist/css/bootstrap.min.css\"\nimport React from \"react\"\nimport loadable from \"@loadable/component\"\n\nexport default (props) => {\n    return (\n        <pre className=\"bg-light\">\n            {props.code}\n        </pre>\n    )\n}"],"sourceRoot":""}