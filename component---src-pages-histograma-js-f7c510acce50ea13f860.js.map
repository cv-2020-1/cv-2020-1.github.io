{"version":3,"sources":["webpack:///./src/assets/mujer.png","webpack:///./src/pages/histograma.js"],"names":["module","exports","img","segmentedImage","hist","Array","fill","window","Sketch","loadable","className","setup","p5","canvasParentRef","createCanvas","width","height","parent","colorMode","HSB","image","loadPixels","x","y","bright","int","brightness","get","map","console","log","index","pixels","updatePixels","push","stroke","translate","k","which","max","line","pop","preload","loadImage","imagen","href"],"mappings":"iFAAAA,EAAOC,QAAU,IAA0B,qD,oCCA3C,kEAIe,qBACd,IAAIC,EACAC,EACGC,EAAO,IAAIC,MAAM,KAAKC,KAAK,GAmJlC,GAAsB,oBAAXC,OAAwB,CAClC,IAAMC,EAASC,aAAS,kBAAM,8DAC9B,OACC,mBAAKC,UAAU,kBACd,8EACA,6cASA,YAACF,EAAD,CAAQG,MAxEX,SAAeC,EAAIC,GAClBD,EAAGE,aAAyB,EAAZZ,EAAIa,MAAwB,EAAbb,EAAIc,OAAa,IAAIC,OAAOJ,GAC3DD,EAAGM,UAAUN,EAAGO,IAAK,KACrBP,EAAGQ,MAAMlB,EAAK,EAAG,GAEjBA,EAAImB,aAGJ,IAAK,IAAIC,EAAI,EAAGA,EAAIpB,EAAIa,MAAOO,IAC9B,IAAK,IAAIC,EAAI,EAAGA,EAAIrB,EAAIc,OAAQO,IAAK,CACpC,IAAIC,EAASZ,EAAGa,IAAIb,EAAGc,WAAWd,EAAGe,IAAIL,EAAGC,KAC5CnB,EAAKoB,KAIPpB,EAAOA,EAAKwB,KAAI,SAACN,GAAD,OAAc,IAANA,EAAU,EAAIA,KACtCO,QAAQC,IAAI1B,GAWZD,EAAekB,aACf,IAAK,IAAIC,EAAI,EAAGA,EAAInB,EAAeY,MAAOO,IACzC,IAAK,IAAIC,EAAI,EAAGA,EAAIpB,EAAea,OAAQO,IAAK,CAC/C,IAAIQ,EAAyC,GAAhCT,EAAIC,EAAIpB,EAAeY,OAChCH,EAAGa,IAAIb,EAAGc,WAAWd,EAAGe,IAAIL,EAAGC,MAAQ,KAC1CpB,EAAe6B,OAAOD,EAAQ,GAAK,EACnC5B,EAAe6B,OAAOD,EAAQ,GAAK,EACnC5B,EAAe6B,OAAOD,EAAQ,GAAK,GACzBnB,EAAGa,IAAIb,EAAGc,WAAWd,EAAGe,IAAIL,EAAGC,KAAO,MAChDpB,EAAe6B,OAAOD,EAAQ,GAAK,IACnC5B,EAAe6B,OAAOD,EAAQ,GAAK,IACnC5B,EAAe6B,OAAOD,EAAQ,GAAK,KAItC5B,EAAe8B,eACfrB,EAAGQ,MAAMjB,EAAgB,EAAGD,EAAIc,OAAS,IAGzCJ,EAAGsB,OACHtB,EAAGuB,OAAO,OACJvB,EAAGwB,UAAUlC,EAAIa,MAAQ,EAAG,GAElC,IAAK,IAAIsB,EAAI,EAAGA,EAAInC,EAAIa,MAAOsB,GAAK,EAAG,CACtC,IAAIC,EAAQ1B,EAAGa,IAAIb,EAAGgB,IAAIS,EAAG,EAAGnC,EAAIa,MAAO,EAAG,MAC1CQ,EAAIX,EAAGgB,IAAIxB,EAAKkC,GAAQ,EAAG1B,EAAG2B,IAAInC,GAAOF,EAAIc,OAAQ,GACzDJ,EAAG4B,KAAKH,EAAGnC,EAAIc,OAAQqB,EAAGd,GAE3BX,EAAG6B,OAiBqBC,QA7EzB,SAAiB9B,GAChBV,EAAMU,EAAG+B,UAAUC,KACnBzC,EAAiBS,EAAG+B,UAAUC,QA4E5B,qCACA,sBACC,sBAAI,iBAAGC,KAAK,oDAAR,iBACJ,sBAAI,iBAAGA,KAAK,qDAAR,wBACJ,sBAAI,iBAAGA,KAAK,8DAAR,wBACJ,sBAAI,iBAAGA,KAAK,iDAAR,mBACJ,sBAAI,iBAAGA,KAAK,kDAAR,mDACJ,sBAAI,iBAAGA,KAAK,wDAAR,yDACJ,iFACA,+KAIA,qHAQH,OAAO","file":"component---src-pages-histograma-js-f7c510acce50ea13f860.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/mujer-b9d874a2aec8953de70bd3dcd0b58d89.png\";","import React from \"react\";\nimport loadable from \"@loadable/component\";\nimport imagen from \"../assets/mujer.png\";\n\nexport default () => {\n\tvar img;\n\tvar segmentedImage;\n    var hist = new Array(256).fill(0);\n    //var minThreshold = 0;\n\t//var minVar = 0;\n\t//var probability = new Array(256).fill(0);\n\n\t/*\n    function otsu(p5, image) {\n        //Calculo de la probabilidad para cada valor de intensidad\n        p5.colorMode(p5.HSB, 255);\n        image.loadPixels();\n        var imageTotalPixels = image.pixels.length / 4;\n\n        // console.log(\"imageTotalPixels\", imageTotalPixels);\n        \n        for (let x = 0; x < image.width; x++) {\n            for (let y = 0; y < image.height; y++) {\n                // var index = (x + y * img.width) * 4;\n                var bright = p5.int(p5.brightness(p5.get(x, y)));\n                // var h = img.pixels[index + 0];\n                // var s = img.pixels[index + 1];\n                // var l = img.pixels[index + 2];\n                // var a = img.pixels[index + 3];\n                hist[bright]++;\n            }\n        }\n\n        console.log(\"hist\", hist)\n        for (var i = 0; i < 255; i++) {\n            probability[i] = hist[i] / imageTotalPixels;\n        }\n\n        console.log(\"probability\", probability);\n        //iterar sobre todos los posibles Thresholds y encontrar la varianza minima\n        for(var t = 0; t < 255; t++) {\n            //pesos clase 1 y 2\n            var c1Weight = 0;\n            var c2Weight = 0;\n            for(var i = 0; i < t; i++) {\n                c1Weight += probability[i];\n            }\n            for(var i = t + 1; i < 255; i++) {\n                c2Weight += probability[i];\n            }\n\n            //promedios calse 1 y 2\n            var c1Mean = 0;\n            var c2Mean = 0;\n            for(var i = 0; i < t; i++) {\n                c1Mean += (i * probability[i]) / c1Weight;\n            }\n            for(var i = t + 1; i < 255; i++) {\n                c2Mean += (i * probability[i]) / c2Weight;\n            }\n\n            //varianzas clase 1 y 2\n            var c1Var = 0; \n            var c2Var = 0;\n            for(var i = 0; i < t; i++) {\n                c1Var += (i - c1Mean)**2 * (probability[i] / c1Weight);\n            }\n            for(var i = t + 1; i < 255; i++) {\n                c2Var += (i - c2Mean)**2 * (probability[i] / c2Weight);\n            }\n\n            // console.log(\"t\", t);\n            // console.log(\"c1Weight\", c1Weight);\n            // console.log(\"c1Var\", c1Var);\n            // console.log(\"c2Weight\", c2Weight);\n            // console.log(\"c2Var\", c2Var);\n            var weightedVar = (c1Weight * c1Var) + (c2Weight * c2Var);\n            // console.log(\"weightedVar\", weightedVar);\n            // console.log(\"minVar\", minVar);\n            if(weightedVar > minVar) {\n                // console.log(\"weightedVar\", weightedVar);\n                // console.log(\"t\", t);\n                minVar = weightedVar;\n                minThreshold = t;\n            }\n        }\n        \n        // console.log(\"minThreshold\", minThreshold);\n        return minThreshold;\n    }*/\n\n\tfunction preload(p5) {\n\t\timg = p5.loadImage(imagen);\n\t\tsegmentedImage = p5.loadImage(imagen);\n\t}\n\n\tfunction setup(p5, canvasParentRef) {\n\t\tp5.createCanvas(img.width * 2, img.height * 2 + 50).parent(canvasParentRef);\n\t\tp5.colorMode(p5.HSB, 255);\n\t\tp5.image(img, 0, 0);\n\n\t\timg.loadPixels();\n\n\t\t//Calcula el histograma\n\t\tfor (let x = 0; x < img.width; x++) {\n\t\t\tfor (let y = 0; y < img.height; y++) {\n\t\t\t\tvar bright = p5.int(p5.brightness(p5.get(x, y)));\n\t\t\t\thist[bright]++;\n\t\t\t}\n\t\t}\n\n\t\thist = hist.map((x) => (x === 0 ? 1 : x));\n\t\tconsole.log(hist);\n\n\t\t//promedio histograma\n\t\t// var total = 0;\n\t\t// for(var i = 0; i < hist.length; i++) {\n\t\t//     total += hist[i];\n\t\t// }\n\t\t// var avg = total / hist.length;\n\t\t// var threshold = p5.max(hist) - avg;\t\t\n\n\t\t//Segmenta la imagen\n\t\tsegmentedImage.loadPixels();\n\t\tfor (let x = 0; x < segmentedImage.width; x++) {\n\t\t\tfor (let y = 0; y < segmentedImage.height; y++) {\n\t\t\t\tvar index = (x + y * segmentedImage.width) * 4;\n\t\t\t\tif (p5.int(p5.brightness(p5.get(x, y))) <= 100) {\n\t\t\t\t\tsegmentedImage.pixels[index + 0] = 0;\n\t\t\t\t\tsegmentedImage.pixels[index + 1] = 0;\n\t\t\t\t\tsegmentedImage.pixels[index + 2] = 0;\n\t\t\t\t} else if (p5.int(p5.brightness(p5.get(x, y))) > 100) {\n\t\t\t\t\tsegmentedImage.pixels[index + 0] = 255;\n\t\t\t\t\tsegmentedImage.pixels[index + 1] = 255;\n\t\t\t\t\tsegmentedImage.pixels[index + 2] = 255;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsegmentedImage.updatePixels();\n\t\tp5.image(segmentedImage, 0, img.height + 50);\n\n        // #############################\n\t\tp5.push();\n\t\tp5.stroke(\"red\");\n        p5.translate(img.width + 5, 0);\n        \n\t\tfor (var k = 0; k < img.width; k += 2) {\n\t\t\tvar which = p5.int(p5.map(k, 0, img.width, 0, 255));\n\t\t\tvar y = p5.map(hist[which], 0, p5.max(hist), img.height, 0);\n\t\t\tp5.line(k, img.height, k, y);\n\t\t}\n\t\tp5.pop();\n\t}\n\n\tif (typeof window !== \"undefined\") {\n\t\tconst Sketch = loadable(() => import(\"react-p5\"));\n\t\treturn (\n\t\t\t<div className=\"ml-5 mr-5 my-3\">\n\t\t\t\t<h1>Histograma y segmentación imagen en escala de grises</h1>\n\t\t\t\t<p>\n\t\t\t\t\tPara el proceso de segmentación se uso Thresholding usando el metodo\n\t\t\t\t\tde Otsu para el calculo automatico del valor umbral y el modelo de\n\t\t\t\t\tcolor HSV sobre la imagen para extraer el valor de intensidad del\n\t\t\t\t\tpixel, que es un valor entero entre 0 y (L - 1) siendo L el numero\n\t\t\t\t\tmaximo que un pixel puede representar. Para este caso particular como\n\t\t\t\t\tla imagen esta a escala de grises, L toma un valor de 256; siendo 0\n\t\t\t\t\tnegro puro y 255 blanco puro.\n\t\t\t\t</p>\n\t\t\t\t<Sketch setup={setup} preload={preload} />\n\t\t\t\t<h2>Referencias</h2>\n\t\t\t\t<ul>\n\t\t\t\t\t<li><a href=\"https://en.wikipedia.org/wiki/Image_segmentation\">Segmentación</a></li>\n\t\t\t\t\t<li><a href=\"https://es.wikipedia.org/wiki/Modelo_de_color_HSV\">Modelo de color HSV</a></li>\n\t\t\t\t\t<li><a href=\"https://es.wikipedia.org/wiki/M%C3%A9todo_del_valor_umbral\">Metodo valor umbral</a></li>\n\t\t\t\t\t<li><a href=\"https://en.wikipedia.org/wiki/Otsu%27s_method\">Metodo de Otsu</a></li>\n\t\t\t\t\t<li><a href=\"https://processing.org/examples/histogram.html\">https://processing.org/examples/histogram.html</a></li>\n\t\t\t\t\t<li><a href=\"https://editor.p5js.org/ebenjmuse/sketches/HyPfeGkCZ\">https://editor.p5js.org/ebenjmuse/sketches/HyPfeGkCZ</a></li>\n\t\t\t\t\t<li>Handbook of Image and Video Processing (Second Edition)</li>\n\t\t\t\t\t<li>\n\t\t\t\t\t\tMetz, M. (2018). Optimum Global Thresholding Using Otsu´s Method.\n\t\t\t\t\t\thttps://github.com/Michael-Metz/image-processing/blob/master/otsus-method-paper.pdf\n\t\t\t\t\t</li>\n\t\t\t\t\t<li>\n\t\t\t\t\t\tDigital Image Processing (CS/ECE 545) Lecture 2: Histograms and\n\t\t\t\t\t\tPoint Operations (Part 1)\n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t);\n\t} else {\n\t\treturn null;\n\t}\n};\n"],"sourceRoot":""}